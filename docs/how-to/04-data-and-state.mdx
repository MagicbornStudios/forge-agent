---
created: 2026-02-04
updated: 2026-02-04
---

# 04 – Data and state

Draft state (Zustand), server state (TanStack Query), and the rule: **client talks only to our Next API**.

## Draft state (Zustand)

Editable document state lives in Zustand stores (e.g. `apps/studio/lib/store.ts` for graph, `apps/studio/lib/domains/video/store.ts` for video). Actions update the draft; **Save** persists via a mutation that calls the API and invalidates queries.

## Server state (TanStack Query)

List and single-document data is fetched through Next API routes and cached with TanStack Query. Keys and hooks live in `apps/studio/lib/data/`: `keys.ts`, hooks in `hooks/` (e.g. `useGraphs`, `useGraph(id)`, `useSaveGraph`, `useCreateGraph`, `useVideoDocs`, `useCreateVideoDoc`). The hooks call the **OpenAPI-generated client** in `apps/studio/lib/api-client/` (generated from the spec at `/api/docs`). Do not use raw `fetch` for API routes. See [docs/agent-artifacts/core/decisions.md](../agent-artifacts/core/decisions.md) and [docs/11-tech-stack.mdx](../11-tech-stack.mdx).

## API boundary

The browser never calls Payload REST/GraphQL directly. All server-state goes through our Next API routes. The **typed client** is generated from the OpenAPI spec (which is built from JSDoc in `app/api/` via next-swagger-doc). Regenerate with `pnpm generate-client`. Swagger UI: `/api-doc`; spec: `/api/docs`.

## Loading and saving a document

- **Load**: On app load, read `lastGraphId` from localStorage (or first from list, or create empty). The component uses `useGraph(id)` (and `useGraphs()` / `useCreateGraph()` as needed); server data is synced into the graph store. No raw fetch—hooks use the generated client.
- **Save**: User clicks Save (or `forge_commit`); component calls `useSaveGraph().mutate()` which uses the generated client for `PATCH /api/graphs/:id`, then invalidates `studioKeys.graph(id)` and `studioKeys.graphs()`.

Code: `apps/studio/app/page.tsx` (initial load), `apps/studio/lib/data/hooks/use-save-graph.ts` (mutation), `apps/studio/lib/store.ts` (draft state only).

## What the AI can do at this stage

The agent could call APIs via tools if you exposed them; there are no workspace-specific actions yet. Once you add a domain contract (context + actions), the AI can read context and run actions that update the draft and trigger save.

**Next:** [05 – Building a workspace from scratch](05-building-a-workspace.md)
