---
title: Editor architecture
created: 2026-02-04
updated: 2026-02-07
---

# Editor architecture

## Mental model

- **WorkspaceShell** - Layout and surfaces (header, toolbar, left, main, right, statusBar, bottom, overlays). Declarative slots only.
- **Editor controller (system)** - Store + adapter + subscriptions (e.g. Zustand).
- **Editor bridge (per editor)** - Converts editor state/events into shared Selection and commands.
- **Chat orchestrator** - Reads shared state, emits intents, proposes drafts, triggers navigation.

Rule: **shared UI stays dumb**; capabilities live in a **headless controller layer**.

**AI-first:** The chat UI operates the main application. The agent reads editor context and performs edits via system actions. See [AI editor integration](../15-ai-workspace-integration.mdx) and [Adding system actions](../14-adding-domain-actions.mdx).

---

## Editor UI kit surfaces

| Surface | Purpose |
|--------|--------|
| **Header** | App bar: project switcher (app-level), editor tabs, theme switcher, current user, app settings; then per-editor breadcrumbs and Left / Center / Right |
| **Toolbar** | Primary actions; declarative `ToolbarGroup[]` or Left/Center/Right slots |
| **Main** | Primary editor surface (React Flow, Lexical, JointJS, Twick) |
| **Inspector** | Selection-driven properties; `sections[]` with `when(selection)` + `render` |
| **StatusBar** | Saving, validation, play state, selection summary |
| **Overlays** | Modals/drawers/popovers; **declarative list** (`OverlaySpec[]`), no registry |
| **LeftPanel** | Optional: library, palette, navigator |
| **BottomPanel** | Optional: timeline, logs, errors (a slot, not a core concept) |

---

## Selection model

Shared shape; every editor adapts into it:

- **none** - No selection.
- **entity** - `{ type: 'entity', entityType, id, ref?, meta? }` (node, edge, character, etc.).
- **textRange** - `{ type: 'textRange', anchor, focus, textPreview?, meta? }` (e.g. Lexical).
- **canvasObject** - `{ type: 'canvasObject', system, id, meta? }` (e.g. Twick, JointJS).

Helpers: `isNone`, `isEntity`, `isTextRange`, `isCanvasObject`, `toEntitySelection(kind, id)`.
Legacy: `SelectionKind` / `LegacySelection` for backward compat; map to entity in adapters.

---

## Inspector section pattern

Inspector is **composition**, not a monolith:

- Inspector component (`WorkspaceInspector`) receives `selection` and `sections: InspectorSection[]`.
- Each section: `id`, `title`, `when(selection) => boolean`, `render({ selection }) => ReactNode`.
- Only sections that pass `when(selection)` are rendered. Handles Dialogue node/edge, Writer range, Characters element, etc.

---

## Toolbar model

Declarative **data + slots**:

- `ToolbarGroup`: `id`, `align` ('start' | 'center' | 'end'), `items: ToolbarItem[]`.
- `ToolbarItem`: `button` | `toggle` | `menu` | `custom` (with id, label, onClick / onToggle / render / children).
- Pass `groups` to `WorkspaceToolbar` to render from data; otherwise use `Left`/`Center`/`Right` slots.

---

## Overlays pattern

- **No registry.** One list per editor: `OverlaySpec[]` with `id`, `type`, `title?`, `size?`, `render({ payload, onDismiss })`.
- Editor state holds `activeOverlay: { id, payload? } | null`. Set to open; `onDismiss()` clears.
- `WorkspaceOverlaySurface` finds spec by `activeOverlay.id` and calls `render`. No file scanning or generators.

---

## Shared types (from @forge/shared)

- **Selection** - Discriminant union: none | entity | textRange | canvasObject.
- **Focus** - `FocusTarget = 'chat' | 'viewport' | 'inspector' | { custom }`.
- **OverlaySpec** / **ActiveOverlay** - Declarative overlays; no registry.
- **ToolbarGroup** / **ToolbarItem** - Declarative toolbar.
- **InspectorSection** - when(selection) + render(selection).
- **WorkspaceUISpec** - slots + overlays list (one place per editor). Legacy naming retained for compatibility.
- **ModalRoute** / **ModalRegistry** - Legacy; prefer OverlaySpec + WorkspaceOverlaySurface.
- **DeepLink** / **NavRequest**, **Draft**, **Proposal**, **WorkspaceCapabilities** - Unchanged (legacy naming maps to editors).

---

## Chat-first loop

1. **Context snapshot** - Editor exposes id, selection, open document/template, minimal context for LLM.
2. **Proposal pipeline** - Create proposal -> user reviews -> apply/reject via capabilities.
3. **Navigation and reveal** - Deep link + focus + highlight.
4. **Overlays** - Open by setting `activeOverlay`; no registry.

---

## Unified API: common capabilities + per-editor actions

The Copilot agent operates on editors in a consistent way without a single over-abstracted "createEntity" API.

- **Common capabilities** (every editor implements):
  - `getSelection()` - Returns shared Selection (entity / textRange / canvasObject / none).
  - `getContextSnapshot()` - editorId, selection, openDocumentId, optional context (e.g. selected node label).
  - `revealSelection()` - Fit viewport to selection (Dialogue: fitView to node/edge; Writer: scroll to range; etc.).
  - `openModal` / overlay - Same pattern everywhere; editor sets activeOverlay.
  - `navigateTo(target)` - Deep links; host implements router.

- **System actions** (per editor; registered with CopilotKit when that editor is active):
  - Dialogue: createNode, updateNode, deleteNode, createEdge, getGraph, openCreateNodeModal, revealSelection.
  - Writer (future): insertText, replaceRange, formatSelection, getDocument.
  - Characters (future): createElement, updateElement, createLink.
  - Video/Twick (future): addLayer, updateElement, etc.

The agent uses `editorId` and `viewportType` from context to choose which actions to call. No file scanning or registry in shared UI.

---

## Editor viewport and selection

Editors expose selection (e.g. React Flow `onSelectionChange`) and optionally a viewport handle (e.g. `fitView`, `fitViewToNodes`) so the editor can implement `revealSelection()`. See `EditorViewportHandle` in capabilities.ts. Dialogue wires React Flow via `onInit` and `onSelectionChange` and maps to shared Selection (forge.node / forge.edge).

---

## Editor bridges (per system, later)

- **Dialogue (React Flow)** - entity selection (`forge.node`, `forge.edge`); reveal = fitView/zoomTo. Implemented.
- **Writer (Lexical)** - textRange; reveal = scroll selection into view.
- **Characters (JointJS)** - entity (`characters.element`, `characters.link`); reveal = center paper.
- **Video (Twick)** - canvasObject or entity; reveal = highlight/scroll timeline.

No framework abstraction over editors; only the shared Selection + capability contract at the edges.
