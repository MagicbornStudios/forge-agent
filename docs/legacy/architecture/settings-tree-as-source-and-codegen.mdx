---
title: Settings tree-as-source and codegen
created: 2026-02-10
updated: 2026-02-10
---

# Settings: tree-as-source and generated contract

Settings in Studio use a **tree-as-source** pattern: the React tree (SettingsSection + SettingsField) is the single source of truth. A codegen step produces the "contract" (defaults, types) consumed by the store and config. This doc describes what is in scope, what is not, and how to add or change settings.

---

## What is in scope

- **Settings only.** Each setting is defined in the tree by placing a **SettingsField** (with `fieldKey`, `type`, `label`, `default`, and optional `description`/`placeholder`/`options`) inside a **SettingsSection**, under the appropriate provider (AppSettingsProvider for app scope, ViewportSettingsProvider for viewport scope).
- **Form-field pattern:** SettingsSection and SettingsField **render** the form in the sidebar (like shadcn FormField/FormItem). SettingsField wraps the actual input (Input, Switch, Select, Textarea): it binds value/onChange to the settings store and renders label, description, reset, and inheritance badges. The **input is the child** of SettingsField (element or render prop).
- At runtime, sections **register on mount** with the settings registry so codegen can collect field metadata; the same tree that defines the fields is the one rendered in the sidebar.
- A **codegen step** (run via `pnpm settings:generate` or as part of build) mounts the same tree in a test environment, reads the registry, and writes **generated/defaults.ts** (and optionally types). The store and config import from generated; the sidebar renders the form trees (AppSettingsRegistrations for App tab, GraphViewportSettings for Viewport tab) directly—no separate "read registry → SettingsPanel" path for those scopes.

---

## What is not in scope

- **Menus and toolbars** use the registry/tree pattern (place components, they register) but do **not** persist a "contract" and do **not** run codegen. They are registry-only.
- **Rich collections** (e.g. projects, forge-graphs) remain **schema-first**: Payload collection config is the source of truth; types are generated by Payload. We do not use tree-as-source or settings-style codegen for those.
- Only **settings** use "tree as source → generate contract."

---

## Current vs new flow

**Before (schema-first):** A hand-written `SETTINGS_SCHEMA` array in `lib/settings/schema.ts` defined keys, types, labels, defaults, and scopes. From it we derived `getAppDefaults()`, `getProjectDefaults()`, `getViewportDefaultsFromSchema()`, and `buildSectionsForScope()` → `APP_SETTINGS_SECTIONS` etc. Config and store imported from schema; the panel merged schema-derived sections with registry sections.

**After (tree-as-source + form-field):** The tree (SettingsSection + SettingsField with `default`, wrapping real inputs) is the only definition and **is** the form: the sidebar renders it directly (App tab = AppSettingsProvider + AppSettingsRegistrations; Viewport tab = ViewportSettingsProvider + GraphViewportSettings). Sections still register on mount so codegen can read the registry and write `generated/defaults.ts`. Config imports from generated; store uses config as today.

---

## How to add a setting

1. Add or edit a **SettingsField** in the React tree under the correct provider (e.g. inside `AppSettingsRegistrations` for app scope, or inside `GraphViewportSettings` under ViewportSettingsProvider for viewport scope).
2. Set **fieldKey**, **type**, **label**, and **default** (and optionally description, placeholder, options). Pass the **input** as children: e.g. `<SettingsField ... type="text"><Input placeholder="..." /></SettingsField>`, or `<SettingsField ... type="toggle"><Switch /></SettingsField>`, or a render prop `{({ value, onChange }) => <Select value={value} onValueChange={onChange}>...</Select>}` for selects.
3. Run **pnpm settings:generate** so generated defaults are updated.
4. No separate schema file to edit; the tree is the source and the form.

---

## Codegen trigger and output

- **Trigger:** Run `pnpm settings:generate` in the studio app (sets `SETTINGS_CODEGEN=1` and runs the codegen Jest test). On Windows (cmd), use `set SETTINGS_CODEGEN=1&& pnpm exec jest settings-codegen` or run from Git Bash. Optionally, wire the codegen into `pnpm build` so generated files are always fresh.
- **Output location:** `apps/studio/lib/settings/generated/` — at minimum `defaults.ts` (exported `APP_DEFAULTS`, viewport defaults, and helpers like `getViewportDefaults(editorId, viewportId)`). Optionally `settings-keys.ts` for typed keys.
- **Consumers:** `apps/studio/lib/settings/config.ts` imports from `./generated/defaults`; the store continues to use `SETTINGS_CONFIG` for initial state and `getOverridesForScope`. The Payload collection (`settings-overrides`) is unchanged; it still stores a single `settings` JSON field.

---

## Related

- [decisions.md](../agent-artifacts/core/decisions.md) — ADR "Settings: tree-as-source and generated contract"
- [Shared panel content and editor-scoped contributions](../agent-artifacts/core/decisions.md) — Same register-on-mount pattern for panels and settings sections
- [Studio as single entrypoint](../agent-artifacts/core/decisions.md) — Studio owns providers including StudioSettingsProvider
