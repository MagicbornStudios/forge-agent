import path from 'node:path';

import { PLANNING_FILES, PLANNING_PROMPTS_DIR } from '../lib/paths.mjs';
import { fileExists, readText, writeText } from '../lib/fs-utils.mjs';
import { getAutoCommitEnabled, getCommitScope, loadPlanningConfig } from '../lib/config.mjs';
import {
  assertCommitResult,
  commitPaths,
  formatArtifactCommitMessage,
  formatTaskCommitMessage,
} from '../lib/git.mjs';
import { askYesNo } from '../lib/prompting.mjs';
import {
  ensurePhaseDir,
  findPhase,
  getPhaseExecutionState,
  listPhasePlanFiles,
  parsePlanFrontmatter,
  parsePlanTasks,
} from '../lib/planning.mjs';

function sortPlanPaths(planPaths) {
  return [...planPaths].sort((a, b) => {
    const aContent = readText(a, '');
    const bContent = readText(b, '');
    const aFrontmatter = parsePlanFrontmatter(aContent);
    const bFrontmatter = parsePlanFrontmatter(bContent);

    const aWave = Number(aFrontmatter.wave || 0);
    const bWave = Number(bFrontmatter.wave || 0);
    if (aWave !== bWave) return aWave - bWave;

    return path.basename(a).localeCompare(path.basename(b));
  });
}

function isGapClosurePlan(planContent) {
  const frontmatter = parsePlanFrontmatter(planContent);
  return frontmatter.gap_closure === true || String(frontmatter.gap_closure || '').toLowerCase() === 'true';
}

function updateState(phase, planId, taskName) {
  const stateTemplate = `# Project State\n\n## Current Position\n\nPhase: ${phase.phaseNumber}\nPlan: ${planId}\nStatus: In progress\nLast activity: ${new Date().toISOString()} - ${taskName}\n\n## Execution\n\n- Active phase: ${phase.name}\n- Active plan: ${planId}\n- Active task: ${taskName}\n`;

  writeText(PLANNING_FILES.state, stateTemplate);
}

function markRoadmapPhaseComplete(phaseNumber) {
  const roadmap = readText(PLANNING_FILES.roadmap, '');
  const escaped = phaseNumber.replace('.', '\\.');
  const updated = roadmap.replace(new RegExp(`^- \\[ \\] \\*\\*Phase ${escaped}:`, 'm'), `- [x] **Phase ${phaseNumber}:`);
  writeText(PLANNING_FILES.roadmap, updated);
}

function summaryHeader(phase, planId) {
  return `# Phase ${phase.phaseNumber}: ${phase.name} - Plan ${planId} Summary\n\n**Generated by forge-loop execute-phase**\n\n## Tasks\n`;
}

function taskLineRegex(taskNumber) {
  return new RegExp(`^- \\[([ xX])\\] ${taskNumber.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\. .*$`, 'gm');
}

function upsertSummaryTask(summaryPath, index, taskName, completed) {
  const taskNumber = String(index).padStart(2, '0');
  const matcher = taskLineRegex(taskNumber);
  const current = readText(summaryPath, '');
  const base = current.trim() ? current : `${current.trimEnd()}\n`;
  const existingMatches = [...base.matchAll(matcher)];
  const alreadyDone = existingMatches.some((match) => String(match[1]).toLowerCase() === 'x');
  const done = completed || alreadyDone;
  const line = `- [${done ? 'x' : ' '}] ${taskNumber}. ${taskName}`;

  if (existingMatches.length === 0) {
    const content = base.trimEnd();
    writeText(summaryPath, `${content}\n${line}\n`);
    return;
  }

  let replaced = false;
  let duplicateCount = 0;
  const updated = base
    .replace(matcher, () => {
      if (!replaced) {
        replaced = true;
        return line;
      }
      duplicateCount += 1;
      return '';
    })
    .replace(/\n{3,}/g, '\n\n');

  writeText(summaryPath, duplicateCount > 0 ? updated.trimEnd() + '\n' : updated);
}

export async function runExecutePhase(phaseNumber, options = {}) {
  if (!fileExists(PLANNING_FILES.roadmap)) {
    throw new Error('ROADMAP.md not found. Run forge-loop new-project first.');
  }

  const roadmap = readText(PLANNING_FILES.roadmap, '');
  const phase = findPhase(roadmap, phaseNumber);
  if (!phase) {
    throw new Error(`Phase ${phaseNumber} not found in .planning/ROADMAP.md`);
  }

  const phaseDir = ensurePhaseDir(phase.phaseNumber, phase.name);
  const allPlans = sortPlanPaths(listPhasePlanFiles(phaseDir.fullPath));
  if (allPlans.length === 0) {
    throw new Error(`No plan files found for phase ${phase.phaseNumber}. Run forge-loop plan-phase first.`);
  }

  const planPaths = options.gapsOnly
    ? allPlans.filter((planPath) => isGapClosurePlan(readText(planPath, '')))
    : allPlans;

  if (planPaths.length === 0) {
    throw new Error(`No matching plans found for phase ${phase.phaseNumber}.`);
  }

  const config = loadPlanningConfig();
  const autoCommit = options.autoCommit ?? getAutoCommitEnabled(config);
  const commitScope = getCommitScope(config);
  const completedPlans = [];

  for (const planPath of planPaths) {
    const planName = path.basename(planPath).replace('-PLAN.md', '');
    const planId = planName.split('-').slice(-1)[0];
    const planContent = readText(planPath, '');
    const taskNames = parsePlanTasks(planContent);

    const summaryPath = path.join(phaseDir.fullPath, `${planName}-SUMMARY.md`);
    if (!fileExists(summaryPath)) {
      writeText(summaryPath, `${summaryHeader(phase, planId)}\n`);
    }

    for (let index = 0; index < taskNames.length; index += 1) {
      const taskName = taskNames[index];
      const taskNumber = String(index + 1).padStart(2, '0');

      const shouldMarkDone = options.nonInteractive
        ? true
        : await askYesNo(`Mark task ${taskNumber} for ${planName} as completed? (${taskName})`, true);

      upsertSummaryTask(summaryPath, index + 1, taskName, shouldMarkDone);
      updateState(phase, planName, taskName);

      if (autoCommit && shouldMarkDone) {
        const commitFiles = [summaryPath, PLANNING_FILES.state].map((item) => path.relative(process.cwd(), item).replace(/\\/g, '/'));
        const commitResult = commitPaths(
          process.cwd(),
          formatTaskCommitMessage(phase.phaseNumber, planId, taskNumber, taskName),
          commitFiles,
          { commitScope, allowOutOfScope: options.allowOutOfScope === true },
        );
        assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} ${planName} task ${taskNumber}`);
      }
    }

    completedPlans.push(planName);

    if (autoCommit) {
      const commitFiles = [summaryPath].map((item) => path.relative(process.cwd(), item).replace(/\\/g, '/'));
      const commitResult = commitPaths(
        process.cwd(),
        formatArtifactCommitMessage(`summarize plan ${planName}`),
        commitFiles,
        { commitScope, allowOutOfScope: options.allowOutOfScope === true },
      );
      assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} summarize ${planName}`);
    }
  }

  const executionState = getPhaseExecutionState(phaseDir.fullPath);
  if (executionState.complete) {
    markRoadmapPhaseComplete(phase.phaseNumber);
    if (autoCommit) {
      const commitResult = commitPaths(
        process.cwd(),
        formatArtifactCommitMessage(`mark phase ${phase.phaseNumber} complete in roadmap`),
        [path.relative(process.cwd(), PLANNING_FILES.roadmap).replace(/\\/g, '/')],
        { commitScope, allowOutOfScope: options.allowOutOfScope === true },
      );
      assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} roadmap`);
    }
  }

  const promptPath = path.join(PLANNING_PROMPTS_DIR, `${phase.phaseNumber}-execute-prompt.md`);
  writeText(
    promptPath,
    `# Forge Loop Execute Prompt - Phase ${phase.phaseNumber}\n\nUse this with a coding agent or manual execution:\n1. Open plan files in ${path.relative(process.cwd(), phaseDir.fullPath).replace(/\\/g, '/')}\n2. Execute tasks sequentially within wave order.\n3. Keep summary files updated after each completed task.\n4. Run forge-loop verify-work ${phase.phaseNumber} after execution.\n`,
  );

  if (autoCommit) {
    const commitResult = commitPaths(
      process.cwd(),
      formatArtifactCommitMessage(`update execute prompt for phase ${phase.phaseNumber}`),
      [path.relative(process.cwd(), promptPath).replace(/\\/g, '/')],
      { commitScope, allowOutOfScope: options.allowOutOfScope === true },
    );
    assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} prompt`);
  }

  return {
    phase,
    completedPlans,
    executionState,
    promptPath,
  };
}
