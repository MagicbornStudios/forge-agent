import path from 'node:path';

import { PLANNING_FILES, PLANNING_PROMPTS_DIR } from '../lib/paths.mjs';
import { fileExists, readText, writeText } from '../lib/fs-utils.mjs';
import { getAutoCommitEnabled, getCommitScope, loadPlanningConfig } from '../lib/config.mjs';
import {
  assertCommitResult,
  commitPaths,
  formatArtifactCommitMessage,
  formatTaskCommitMessage,
} from '../lib/git.mjs';
import { askYesNo } from '../lib/prompting.mjs';
import { ensureHeadlessEnvReady, shouldRunHeadlessEnvGate } from '../lib/env-preflight.mjs';
import {
  ensurePhaseDir,
  findPhase,
  getPhaseExecutionState,
  listPhasePlanFiles,
  parsePlanFrontmatter,
  parsePlanTasks,
} from '../lib/planning.mjs';
import { enrichStageResult } from '../lib/runtime/results.mjs';
import { createStageRunnerContext, finalizeStageRunnerContext } from '../lib/runtime/stage-runner.mjs';

function sortPlanPaths(planPaths) {
  return [...planPaths].sort((a, b) => {
    const aContent = readText(a, '');
    const bContent = readText(b, '');
    const aFrontmatter = parsePlanFrontmatter(aContent);
    const bFrontmatter = parsePlanFrontmatter(bContent);

    const aWave = Number(aFrontmatter.wave || 0);
    const bWave = Number(bFrontmatter.wave || 0);
    if (aWave !== bWave) return aWave - bWave;

    return path.basename(a).localeCompare(path.basename(b));
  });
}

function isGapClosurePlan(planContent) {
  const frontmatter = parsePlanFrontmatter(planContent);
  return frontmatter.gap_closure === true || String(frontmatter.gap_closure || '').toLowerCase() === 'true';
}

function updateState(phase, planId, taskName) {
  const stateTemplate = `# Project State\n\n## Current Position\n\nPhase: ${phase.phaseNumber}\nPlan: ${planId}\nStatus: In progress\nLast activity: ${new Date().toISOString()} - ${taskName}\n\n## Execution\n\n- Active phase: ${phase.name}\n- Active plan: ${planId}\n- Active task: ${taskName}\n`;

  writeText(PLANNING_FILES.state, stateTemplate);
}

function markRoadmapPhaseComplete(phaseNumber) {
  const roadmap = readText(PLANNING_FILES.roadmap, '');
  const escaped = phaseNumber.replace('.', '\\.');
  const updated = roadmap.replace(new RegExp(`^- \\[ \\] \\*\\*Phase ${escaped}:`, 'm'), `- [x] **Phase ${phaseNumber}:`);
  writeText(PLANNING_FILES.roadmap, updated);
}

function summaryHeader(phase, planId) {
  return `# Phase ${phase.phaseNumber}: ${phase.name} - Plan ${planId} Summary\n\n**Generated by forge-loop execute-phase**\n\n## Tasks\n`;
}

function taskLineRegex(taskNumber) {
  return new RegExp(`^- \\[([ xX])\\] ${taskNumber.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\. .*$`, 'gm');
}

function upsertSummaryTask(summaryPath, index, taskName, completed) {
  const taskNumber = String(index).padStart(2, '0');
  const matcher = taskLineRegex(taskNumber);
  const current = readText(summaryPath, '');
  const base = current.trim() ? current : `${current.trimEnd()}\n`;
  const existingMatches = [...base.matchAll(matcher)];
  const alreadyDone = existingMatches.some((match) => String(match[1]).toLowerCase() === 'x');
  const done = completed || alreadyDone;
  const line = `- [${done ? 'x' : ' '}] ${taskNumber}. ${taskName}`;

  if (existingMatches.length === 0) {
    const content = base.trimEnd();
    writeText(summaryPath, `${content}\n${line}\n`);
    return;
  }

  let replaced = false;
  let duplicateCount = 0;
  const updated = base
    .replace(matcher, () => {
      if (!replaced) {
        replaced = true;
        return line;
      }
      duplicateCount += 1;
      return '';
    })
    .replace(/\n{3,}/g, '\n\n');

  writeText(summaryPath, duplicateCount > 0 ? `${updated.trimEnd()}\n` : updated);
}

function buildTaskPrompt({ phase, planName, taskNumber, taskName }) {
  return [
    `Phase ${phase.phaseNumber}: ${phase.name}`,
    `Plan: ${planName}`,
    `Task ${taskNumber}: ${taskName}`,
    'Implement this task and summarize the concrete outcome and changed files.',
    'If blocked, explain the blocking reason clearly.',
  ].join('\n');
}

function toStatusFromTurn(turn, shouldMarkDone) {
  if (turn) return turn.ok ? 'completed' : 'blocked';
  return shouldMarkDone ? 'completed' : 'skipped';
}

export async function runExecutePhase(phaseNumber, options = {}) {
  if (!fileExists(PLANNING_FILES.roadmap)) {
    throw new Error('ROADMAP.md not found. Run forge-loop new-project first.');
  }

  const roadmap = readText(PLANNING_FILES.roadmap, '');
  const phase = findPhase(roadmap, phaseNumber);
  if (!phase) {
    throw new Error(`Phase ${phaseNumber} not found in .planning/ROADMAP.md`);
  }

  const config = loadPlanningConfig();
  const runtime = createStageRunnerContext({
    config,
    requestedRunner: options.runner,
    phaseNumber: phase.phaseNumber,
    stage: 'execute',
    keepSession: options.keepRuntimeSession === true,
  });

  const phaseDir = ensurePhaseDir(phase.phaseNumber, phase.name);
  const allPlans = sortPlanPaths(listPhasePlanFiles(phaseDir.fullPath));
  if (allPlans.length === 0) {
    throw new Error(`No plan files found for phase ${phase.phaseNumber}. Run forge-loop plan-phase first.`);
  }

  const planPaths = options.gapsOnly
    ? allPlans.filter((planPath) => isGapClosurePlan(readText(planPath, '')))
    : allPlans;

  if (planPaths.length === 0) {
    throw new Error(`No matching plans found for phase ${phase.phaseNumber}.`);
  }

  if (shouldRunHeadlessEnvGate(config, options)) {
    ensureHeadlessEnvReady(config, {
      headless: options.headless === true,
      nonInteractive: options.nonInteractive === true,
    });
  }

  const autoCommit = options.autoCommit ?? getAutoCommitEnabled(config);
  const commitScope = getCommitScope(config);
  const completedPlans = [];
  const taskResults = [];
  const artifactSet = new Set();

  for (const planPath of planPaths) {
    const planName = path.basename(planPath).replace('-PLAN.md', '');
    const planId = planName.split('-').slice(-1)[0];
    const planContent = readText(planPath, '');
    const taskNames = parsePlanTasks(planContent);

    const summaryPath = path.join(phaseDir.fullPath, `${planName}-SUMMARY.md`);
    if (!fileExists(summaryPath)) {
      writeText(summaryPath, `${summaryHeader(phase, planId)}\n`);
      artifactSet.add(summaryPath);
    }

    for (let index = 0; index < taskNames.length; index += 1) {
      const taskName = taskNames[index];
      const taskNumber = String(index + 1).padStart(2, '0');
      let shouldMarkDone = false;
      let taskTurn = null;

      if (runtime.runnerSelected === 'prompt-pack') {
        shouldMarkDone = options.nonInteractive
          ? true
          : await askYesNo(`Mark task ${taskNumber} for ${planName} as completed? (${taskName})`, true);
      } else {
        taskTurn = await runtime.provider.runTask({
          prompt: buildTaskPrompt({ phase, planName, taskNumber, taskName }),
          metadata: {
            phase: phase.phaseNumber,
            plan: planName,
            taskNumber,
            taskName,
            stage: 'execute',
          },
          writer: runtime.writer,
        });
        shouldMarkDone = taskTurn.ok === true;
      }

      upsertSummaryTask(summaryPath, index + 1, taskName, shouldMarkDone);
      updateState(phase, planName, taskName);
      artifactSet.add(summaryPath);
      artifactSet.add(PLANNING_FILES.state);

      const status = toStatusFromTurn(taskTurn, shouldMarkDone);
      const reason = taskTurn?.reason || (status === 'completed' ? null : 'Task remains open.');
      const filesTouched = Array.isArray(taskTurn?.filesTouched) ? taskTurn.filesTouched : [];
      taskResults.push({
        taskId: `${planName}:${taskNumber}`,
        status,
        reason,
        filesTouched,
      });

      runtime.writer.write(status === 'completed' ? 'task-complete' : 'task-blocked', {
        plan: planName,
        taskNumber,
        taskName,
        reason,
        filesTouched,
      });

      if (autoCommit && shouldMarkDone) {
        const commitFiles = [summaryPath, PLANNING_FILES.state].map((item) => path.relative(process.cwd(), item).replace(/\\/g, '/'));
        const commitResult = commitPaths(
          process.cwd(),
          formatTaskCommitMessage(phase.phaseNumber, planId, taskNumber, taskName),
          commitFiles,
          { commitScope, allowOutOfScope: options.allowOutOfScope === true },
        );
        assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} ${planName} task ${taskNumber}`);
      }
    }

    completedPlans.push(planName);

    if (autoCommit) {
      const commitFiles = [summaryPath].map((item) => path.relative(process.cwd(), item).replace(/\\/g, '/'));
      const commitResult = commitPaths(
        process.cwd(),
        formatArtifactCommitMessage(`summarize plan ${planName}`),
        commitFiles,
        { commitScope, allowOutOfScope: options.allowOutOfScope === true },
      );
      assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} summarize ${planName}`);
    }
  }

  const executionState = getPhaseExecutionState(phaseDir.fullPath);
  if (executionState.complete) {
    markRoadmapPhaseComplete(phase.phaseNumber);
    artifactSet.add(PLANNING_FILES.roadmap);
    if (autoCommit) {
      const commitResult = commitPaths(
        process.cwd(),
        formatArtifactCommitMessage(`mark phase ${phase.phaseNumber} complete in roadmap`),
        [path.relative(process.cwd(), PLANNING_FILES.roadmap).replace(/\\/g, '/')],
        { commitScope, allowOutOfScope: options.allowOutOfScope === true },
      );
      assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} roadmap`);
    }
  }

  const promptPath = path.join(PLANNING_PROMPTS_DIR, `${phase.phaseNumber}-execute-prompt.md`);
  writeText(
    promptPath,
    `# Forge Loop Execute Prompt - Phase ${phase.phaseNumber}\n\nUse this with a coding agent or manual execution:\n1. Open plan files in ${path.relative(process.cwd(), phaseDir.fullPath).replace(/\\/g, '/')}\n2. Execute tasks sequentially within wave order.\n3. Keep summary files updated after each completed task.\n4. Run forge-loop verify-work ${phase.phaseNumber} after execution.\n`,
  );
  artifactSet.add(promptPath);

  if (autoCommit) {
    const commitResult = commitPaths(
      process.cwd(),
      formatArtifactCommitMessage(`update execute prompt for phase ${phase.phaseNumber}`),
      [path.relative(process.cwd(), promptPath).replace(/\\/g, '/')],
      { commitScope, allowOutOfScope: options.allowOutOfScope === true },
    );
    assertCommitResult(commitResult, `execute-phase ${phase.phaseNumber} prompt`);
  }

  const normalizedExecution = {
    planCount: executionState.planCount,
    summaryCount: executionState.summaryCount,
    complete: executionState.complete,
    incompletePlans: executionState.incompletePlans.map((item) => path.basename(item)),
  };

  const nextAction = normalizedExecution.complete
    ? `forge-loop verify-work ${phase.phaseNumber}`
    : `forge-loop execute-phase ${phase.phaseNumber}`;

  const summary = {
    status: normalizedExecution.complete ? 'ready_for_verify' : 'pending_execution',
    nextAction,
    blockingGaps: normalizedExecution.complete ? [] : [...normalizedExecution.incompletePlans],
  };

  const result = enrichStageResult({
    phase,
    completedPlans,
    executionState: normalizedExecution,
    promptPath,
    summary,
    status: summary.status,
    nextAction: summary.nextAction,
    runnerUsed: runtime.runnerSelected,
    taskResults,
    artifactsWritten: [...artifactSet],
  });

  await finalizeStageRunnerContext(runtime, {
    ok: result.status === 'ready_for_verify',
    status: result.status,
    nextAction: result.nextAction,
    taskResults: result.taskResults,
  });

  return result;
}
