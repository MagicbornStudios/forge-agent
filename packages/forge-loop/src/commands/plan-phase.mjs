import path from 'node:path';

import { PLANNING_FILES, PLANNING_PROMPTS_DIR } from '../lib/paths.mjs';
import { fileExists, readText, writeText } from '../lib/fs-utils.mjs';
import { getAutoCommitEnabled, getCommitScope, loadPlanningConfig } from '../lib/config.mjs';
import { assertCommitResult, commitPaths, formatArtifactCommitMessage } from '../lib/git.mjs';
import { ensurePhaseDir, findPhase, listPhasePlanFiles, nextPlanNumber, parsePlanFrontmatter } from '../lib/planning.mjs';
import { validatePlanFrontmatter, validateWaveOrdering } from '../lib/validators.mjs';

function makePlanMarkdown({
  phase,
  plan,
  wave,
  dependsOn = [],
  filesModified = [],
  gapClosure = false,
  goal,
}) {
  const dependsList = dependsOn.length > 0 ? `[${dependsOn.map((item) => `'${item}'`).join(', ')}]` : '[]';
  const filesList = filesModified.length > 0 ? `[${filesModified.map((item) => `'${item}'`).join(', ')}]` : '[]';

  const objective = gapClosure
    ? `Close identified verification/UAT gaps for phase ${phase.phaseNumber}.`
    : `Implement phase ${phase.phaseNumber} deliverables for ${phase.name}.`;

  return `---\nphase: ${phase.phaseNumber}-${phase.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')}\nplan: ${plan}\nwave: ${wave}\ndepends_on: ${dependsList}\nfiles_modified: ${filesList}\nautonomous: true\ngap_closure: ${gapClosure}\nmust_haves:\n  truths:\n    - "${goal || 'Phase goal must be demonstrably implemented.'}"\n    - "Plan ${plan} outputs are reflected in code or docs artifacts."\n  artifacts:\n    - path: ".planning/phases/${phase.phaseNumber}-${phase.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')}/${phase.phaseNumber}-${plan}-SUMMARY.md"\n      provides: "Execution summary for plan ${plan}"\n      min_lines: 10\n  key_links:\n    - from: ".planning/ROADMAP.md"\n      to: ".planning/phases/${phase.phaseNumber}-${phase.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')}/${phase.phaseNumber}-${plan}-SUMMARY.md"\n      via: "plan-to-summary traceability"\n---\n\n<objective>\n${objective}\n</objective>\n\n<context>\n@.planning/PROJECT.md\n@.planning/REQUIREMENTS.md\n@.planning/ROADMAP.md\n@.planning/STATE.md\n</context>\n\n<tasks>\n<task type="auto">\n  <name>Align implementation scope with phase goal</name>\n  <files>.planning/ROADMAP.md, .planning/REQUIREMENTS.md</files>\n  <action>Review current phase requirements and ensure plan intent matches defined scope.</action>\n  <verify>Requirements and roadmap entries align with phase deliverables.</verify>\n  <done>Scope alignment is documented and stable.</done>\n</task>\n\n<task type="auto">\n  <name>Implement or update required artifacts</name>\n  <files>.planning/phases/*, docs/*, apps/*, packages/*</files>\n  <action>Execute this plan's implementation steps and update affected artifacts with explicit traceability.</action>\n  <verify>Relevant files reflect implementation and pass validation checks.</verify>\n  <done>Artifacts are updated with no unresolved placeholders.</done>\n</task>\n\n<task type="auto">\n  <name>Create execution summary and prepare verification</name>\n  <files>.planning/phases/*-SUMMARY.md, .planning/STATE.md</files>\n  <action>Record outcomes, decisions, and remaining concerns for this plan in summary/state files.</action>\n  <verify>Summary file exists and includes measurable outcomes.</verify>\n  <done>Plan outputs are ready for verify-work command.</done>\n</task>\n</tasks>\n`;
}

function buildResearchStub(phase) {
  return `# Phase ${phase.phaseNumber}: ${phase.name} - Research\n\n**Researched:** ${new Date().toISOString()}\n\n## Summary\n\nResearch stub generated by Forge Loop. Fill with concrete stack/pattern findings before deep implementation when needed.\n\n## User Constraints\n\n- Preserve phase scope from roadmap and context docs.\n\n## Recommended Stack\n\n- Reuse existing forge-agent conventions from AGENTS.md and current package architecture.\n\n## Pitfalls\n\n- Avoid introducing parallel source-of-truth artifacts outside .planning.\n`;}

export async function runPlanPhase(phaseNumber, options = {}) {
  if (!fileExists(PLANNING_FILES.roadmap)) {
    throw new Error('ROADMAP.md not found. Run forge-loop new-project first.');
  }

  const roadmap = readText(PLANNING_FILES.roadmap, '');
  const phase = findPhase(roadmap, phaseNumber);
  if (!phase) {
    throw new Error(`Phase ${phaseNumber} not found in .planning/ROADMAP.md`);
  }

  const phaseDir = ensurePhaseDir(phase.phaseNumber, phase.name);
  const writes = [];

  if (!options.skipResearch) {
    const researchPath = path.join(phaseDir.fullPath, `${phase.phaseNumber}-RESEARCH.md`);
    if (!fileExists(researchPath)) {
      writeText(researchPath, buildResearchStub(phase));
      writes.push(researchPath);
    }
  }

  const existingPlans = listPhasePlanFiles(phaseDir.fullPath);
  if (existingPlans.length === 0) {
    const plan01 = nextPlanNumber(phaseDir.fullPath);
    const plan01Path = path.join(phaseDir.fullPath, `${phase.phaseNumber}-${plan01}-PLAN.md`);
    writeText(
      plan01Path,
      makePlanMarkdown({
        phase,
        plan: plan01,
        wave: 1,
        goal: phase.goal,
        filesModified: [],
      }),
    );

    const plan02 = String(Number(plan01) + 1).padStart(2, '0');
    const plan02Path = path.join(phaseDir.fullPath, `${phase.phaseNumber}-${plan02}-PLAN.md`);
    writeText(
      plan02Path,
      makePlanMarkdown({
        phase,
        plan: plan02,
        wave: 2,
        dependsOn: [`${phase.phaseNumber}-${plan01}`],
        goal: phase.goal,
        filesModified: [],
      }),
    );

    writes.push(plan01Path, plan02Path);
  } else if (options.gaps) {
    const next = nextPlanNumber(phaseDir.fullPath);
    const gapPath = path.join(phaseDir.fullPath, `${phase.phaseNumber}-${next}-PLAN.md`);
    writeText(
      gapPath,
      makePlanMarkdown({
        phase,
        plan: next,
        wave: 3,
        dependsOn: existingPlans.map((filePath) => path.basename(filePath).replace('-PLAN.md', '')),
        gapClosure: true,
        goal: phase.goal,
      }),
    );
    writes.push(gapPath);
  }

  const promptPath = path.join(PLANNING_PROMPTS_DIR, `${phase.phaseNumber}-plan-prompt.md`);
  writeText(
    promptPath,
    `# Forge Loop Plan Prompt - Phase ${phase.phaseNumber}\n\nPhase: ${phase.name}\nGoal: ${phase.goal || 'N/A'}\n\nUse generated PLAN files under:\n${path.relative(process.cwd(), phaseDir.fullPath).replace(/\\/g, '/')}\n\nChecklist:\n1. Validate required frontmatter fields.\n2. Confirm wave ordering and dependencies.\n3. Ensure must_haves map to observable behavior.\n`,
  );
  writes.push(promptPath);

  const validationErrors = [];
  const phasePlans = listPhasePlanFiles(phaseDir.fullPath);
  for (const planPath of phasePlans) {
    const validation = validatePlanFrontmatter(readText(planPath, ''));
    if (!validation.valid) {
      validationErrors.push({ planPath, errors: validation.errors });
    }
  }

  if (validationErrors.length > 0) {
    throw new Error(`Plan validation failed: ${JSON.stringify(validationErrors, null, 2)}`);
  }

  const waveValidation = validateWaveOrdering(
    phasePlans.map((planPath) => {
      const frontmatter = parsePlanFrontmatter(readText(planPath, ''));
      return {
        id: path.basename(planPath).replace('-PLAN.md', ''),
        wave: Number(frontmatter.wave || 0),
        dependsOn: Array.isArray(frontmatter.depends_on) ? frontmatter.depends_on : [],
      };
    }),
  );

  if (!waveValidation.valid) {
    throw new Error(`Plan wave validation failed: ${JSON.stringify(waveValidation.issues, null, 2)}`);
  }

  const config = loadPlanningConfig();
  const autoCommit = options.autoCommit ?? getAutoCommitEnabled(config);
  if (autoCommit) {
    const commitFiles = writes.map((item) => path.relative(process.cwd(), item).replace(/\\/g, '/'));
    const commitResult = commitPaths(
      process.cwd(),
      formatArtifactCommitMessage(`plan phase ${phase.phaseNumber}`),
      commitFiles,
      { commitScope: getCommitScope(config), allowOutOfScope: options.allowOutOfScope === true },
    );
    assertCommitResult(commitResult, `plan-phase ${phase.phaseNumber}`);
  }

  return {
    phase,
    phaseDir: phaseDir.fullPath,
    writes,
  };
}
