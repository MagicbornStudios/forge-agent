import { backupFileIfExists, buildEnvContent, isValueSet, readEnvFile, writeTextFile } from './io.mjs';

function commentsByKey(entries) {
  const map = {};
  for (const entry of entries || []) {
    if (entry.description) {
      map[entry.key] = entry.description;
    }
  }
  return map;
}

export async function writeTargetFiles(targetState, options = {}) {
  const backups = [];
  const pending = [];
  const changed = [];
  const policy = options.writePolicy || {};
  const writeEnabled = options.write === true;
  const examplesOnly = options.examplesOnly === true;

  const envLocalPath = targetState.targetPaths.local;
  const examplePath = targetState.targetPaths.example;
  const developmentPath = targetState.targetPaths.development;
  const productionPath = targetState.targetPaths.production;

  const header = [
    '# Generated by forge-env reconcile.',
    '# Safe merge mode: union + preserve.',
  ];

  const commentMap = commentsByKey(targetState.entries);
  if (!examplesOnly) {
    const localContent = buildEnvContent(header, targetState.unionKeys, targetState.mergedValues, commentMap);
    const currentLocal = await readEnvFile(envLocalPath);
    if (currentLocal.raw !== localContent) {
      pending.push(envLocalPath);
      if (writeEnabled) {
        if (policy.backupOnWrite) {
          const backup = await backupFileIfExists(envLocalPath);
          if (backup) backups.push(backup);
        }
        await writeTextFile(envLocalPath, localContent);
        changed.push(envLocalPath);
      }
    }
  }

  if (options.syncExamples) {
    const exampleHeader = [
      '# Generated by forge-env sync-examples.',
      '# Secrets are intentionally blank in this file.',
    ];
    const exampleContent = buildEnvContent(exampleHeader, targetState.unionKeys, targetState.exampleValues, commentMap);
    const currentExample = await readEnvFile(examplePath);
    if (currentExample.raw !== exampleContent) {
      pending.push(examplePath);
      if (writeEnabled) {
        if (policy.backupOnWrite) {
          const backup = await backupFileIfExists(examplePath);
          if (backup) backups.push(backup);
        }
        await writeTextFile(examplePath, exampleContent);
        changed.push(examplePath);
      }
    }
  }

  if (!examplesOnly) {
    for (const modePath of [developmentPath, productionPath]) {
      const existing = await readEnvFile(modePath);
      if (!existing.exists) continue;
      const modeValues = { ...existing.values };
      let touched = false;
      for (const key of targetState.unionKeys) {
        if (!isValueSet(modeValues[key]) && isValueSet(targetState.mergedValues[key])) {
          modeValues[key] = targetState.mergedValues[key];
          touched = true;
        }
      }

      if (!touched) continue;
      const content = buildEnvContent(header, targetState.unionKeys, modeValues, commentMap);
      pending.push(modePath);
      if (writeEnabled) {
        if (policy.backupOnWrite) {
          const backup = await backupFileIfExists(modePath);
          if (backup) backups.push(backup);
        }
        await writeTextFile(modePath, content);
        changed.push(modePath);
      }
    }
  }

  return { pending, changed, backups };
}
