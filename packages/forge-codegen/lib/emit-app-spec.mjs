/**
 * Emit a single app-spec.generated.ts file: canonical shape (workspaces, layout definitions,
 * panel specs with rail, settings defaults, pinned panel ids) and helpers.
 * One import surface per studio app.
 */

/**
 * @param {Array<{ workspaceId: string, label: string, panels: Array<{ id: string, title: string, rail: string }> }>} layouts
 * @param {Record<string, unknown>} settings - merged settings defaults to embed
 * @param {object} options
 * @param {string} [options.appSpecOutputPath]
 * @param {string} [options.panelKeyPrefix] - e.g. 'panel.visible.repo' -> key = prefix + '-' + panelId
 * @param {string} [options.panelKeyFormat] - e.g. 'panel.visible.{workspaceId}-{panelId}'
 * @param {string} [options.layoutIdPrefix] - e.g. 'repo'
 * @param {string} [options.fallbackWorkspaceId]
 * @param {string[]} [options.pinnedPanelIds] - panels that must never be hidden (e.g. ['viewport'])
 * @param {Record<string, Array<{ id: string, label: string, key: string }>>} [options.extraPanels] - per-workspace extra panels (rail default 'main')
 * @param {string} [options.settingsExportName] - e.g. 'SETTINGS_DEFAULTS' or 'REPO_SETTINGS_DEFAULTS'
 * @param {string} [options.sharedTypesImport] - e.g. '@forge/shared'
 */
export function emitAppSpec(layouts, settings, options = {}) {
  const workspaceIds = layouts.map((l) => l.workspaceId);
  const workspaceLabels = Object.fromEntries(layouts.map((l) => [l.workspaceId, l.label]));
  const layoutIdPrefix = options.layoutIdPrefix ?? 'repo';
  const fallbackWorkspaceId = options.fallbackWorkspaceId ?? workspaceIds[0];
  const pinnedPanelIds = options.pinnedPanelIds ?? [];
  const extraPanels = options.extraPanels ?? {};
  const settingsExportName = options.settingsExportName ?? 'SETTINGS_DEFAULTS';
  const sharedTypesImport = options.sharedTypesImport ?? '@forge/shared';
  const appId = options.appId ?? null;
  const appLabel = options.appLabel ?? null;

  function panelKey(panelId, workspaceId) {
    if (options.panelKeyPrefix) {
      return `${options.panelKeyPrefix}-${panelId}`;
    }
    if (options.panelKeyFormat) {
      return options.panelKeyFormat.replace('{workspaceId}', workspaceId).replace('{panelId}', panelId);
    }
    return `panel.visible.${workspaceId}-${panelId}`;
  }

  const layoutDefinitions = {};
  for (const layout of layouts) {
    const baseSpecs = layout.panels.map((p) => ({
      id: p.id,
      rail: p.rail,
      label: p.title,
      key: panelKey(p.id, layout.workspaceId),
    }));
    const extra = (extraPanels[layout.workspaceId] ?? []).map((e) => ({
      id: e.id,
      label: e.label,
      key: e.key,
      rail: 'main',
    }));
    const panelSpecs = [...baseSpecs, ...extra];
    const mainPanels = panelSpecs.filter((p) => p.rail === 'main');
    const mainAnchorPanelId = mainPanels[0]?.id ?? panelSpecs[0]?.id ?? '';
    const mainPanelIds = mainPanels.map((p) => p.id);

    layoutDefinitions[layout.workspaceId] = {
      workspaceId: layout.workspaceId,
      label: layout.label,
      layoutId: `${layoutIdPrefix}-${layout.workspaceId}`,
      mainAnchorPanelId,
      mainPanelIds,
      panelSpecs,
    };
  }

  const layoutDefJson = JSON.stringify(layoutDefinitions, null, 2);
  const settingsJson = JSON.stringify(settings ?? {}, null, 2);

  return `/**
 * Do not edit. Generated by @forge/forge-codegen.
 * Source: workspace components (WORKSPACE_ID, WORKSPACE_LABEL, WorkspaceLayout.Panel).
 * Single import surface for this studio app.
 */

import type { WorkspacePanelSpec, WorkspaceLayoutDefinition } from '${sharedTypesImport}';
${appId != null ? `\n/** App identity (for spec consistency; use on root when desired). */\nexport const APP_ID = ${JSON.stringify(appId)};\nexport const APP_LABEL = ${JSON.stringify(appLabel ?? appId)};\n` : ''}
export const WORKSPACE_IDS = ${JSON.stringify(workspaceIds)} as const;
export type WorkspaceId = (typeof WORKSPACE_IDS)[number];

export const WORKSPACE_LABELS: Record<WorkspaceId, string> = ${JSON.stringify(workspaceLabels, null, 2)};

/** Panel ids that must never be hidden (e.g. viewport-as-canvas). */
export const PINNED_PANEL_IDS: readonly string[] = ${JSON.stringify(pinnedPanelIds)};

const LAYOUT_DEFINITIONS: Record<WorkspaceId, WorkspaceLayoutDefinition> = ${layoutDefJson};

const FALLBACK_WORKSPACE_ID: WorkspaceId = ${JSON.stringify(fallbackWorkspaceId)};

function getDefinitionSafe(workspaceId: string): WorkspaceLayoutDefinition {
  if (workspaceId in LAYOUT_DEFINITIONS) {
    return LAYOUT_DEFINITIONS[workspaceId as WorkspaceId];
  }
  if (process.env.NODE_ENV !== 'production') {
    console.warn(
      '[App spec] Unknown workspace id "%s", falling back to %s.',
      workspaceId,
      FALLBACK_WORKSPACE_ID,
    );
  }
  return LAYOUT_DEFINITIONS[FALLBACK_WORKSPACE_ID];
}

export function getWorkspaceLayoutDefinition(workspaceId: WorkspaceId): WorkspaceLayoutDefinition {
  return LAYOUT_DEFINITIONS[workspaceId];
}

export function getWorkspaceLayoutId(workspaceId: string): string {
  return getDefinitionSafe(workspaceId).layoutId;
}

export function getWorkspacePanelSpecs(workspaceId: string): WorkspacePanelSpec[] {
  return getDefinitionSafe(workspaceId).panelSpecs;
}

function normalizePanelIds(panelIds: unknown[]) {
  return [...new Set(
    (panelIds || [])
      .map((panelId) => String(panelId || '').trim())
      .filter(Boolean),
  )];
}

export function sanitizeWorkspaceHiddenPanelIds(workspaceId: WorkspaceId, panelIds: unknown[]): string[] {
  const definition = getWorkspaceLayoutDefinition(workspaceId);
  const allowedIds = new Set(definition.panelSpecs.map((p) => p.id));
  const pinnedSet = new Set(PINNED_PANEL_IDS);
  const hidden = normalizePanelIds(panelIds)
    .filter((id) => allowedIds.has(id))
    .filter((id) => !pinnedSet.has(id));
  const hiddenSet = new Set(hidden);
  const visibleMainPanels = definition.mainPanelIds.filter((id) => !hiddenSet.has(id));
  if (visibleMainPanels.length === 0) {
    hiddenSet.delete(definition.mainAnchorPanelId);
    const fallbackVisible = definition.mainPanelIds.filter((id) => !hiddenSet.has(id));
    if (fallbackVisible.length === 0 && definition.mainPanelIds[0]) {
      hiddenSet.delete(definition.mainPanelIds[0]);
    }
  }
  return [...hiddenSet].sort((a, b) => a.localeCompare(b));
}

export function createEmptyWorkspaceHiddenPanelMap(): Partial<Record<WorkspaceId, string[]>> {
  return WORKSPACE_IDS.reduce((acc, workspaceId) => {
    acc[workspaceId] = [];
    return acc;
  }, {} as Partial<Record<WorkspaceId, string[]>>);
}

/** Merged settings defaults for this app. */
export const ${settingsExportName} = ${settingsJson} as const;
`;
}
