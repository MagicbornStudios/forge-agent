---
phase: 05-settings-foundation-and-canonical-env-ux
plan: 01
wave: 1
depends_on:
files_modified:
  - apps/repo-studio/payload.config.ts
  - apps/repo-studio/payload/collections/repo-settings-overrides.ts
  - apps/repo-studio/src/lib/settings/types.ts
  - apps/repo-studio/src/lib/settings/merge.ts
  - apps/repo-studio/src/lib/settings/payload-repository.ts
  - apps/repo-studio/src/lib/settings/repository.ts
  - apps/repo-studio/app/api/repo/settings/snapshot/route.ts
  - apps/repo-studio/app/api/repo/settings/upsert/route.ts
  - apps/repo-studio/app/api/repo/settings/reset/route.ts
  - apps/repo-studio/app/api/repo/settings/export/route.ts
  - apps/repo-studio/src/lib/command-policy.ts
  - apps/repo-studio/app/api/repo/commands/list/route.ts
  - apps/repo-studio/app/api/repo/commands/toggle/route.ts
  - apps/repo-studio/app/api/repo/commands/view/route.ts
autonomous: true
must_haves:
  truths:
    - "RepoStudio app runtime must persist settings through Payload + SQLite APIs instead of `.repo-studio/local.overrides.json`."
    - "Settings APIs must support app/workspace/local scopes with deterministic merge precedence."
    - "App runtime routes that touch settings persistence must stay Node runtime and compile in `next build`."
  artifacts:
    - path: ".planning/phases/05-settings-foundation-and-canonical-env-ux/05-01-SUMMARY.md"
      provides: "Implementation summary for Payload-backed settings backbone and command policy hydration cutover."
      min_lines: 12
  key_links:
    - from: ".planning/ANALYSIS-REFERENCES.md"
      to: "repo_studio_analysis/PRD.md"
      via: "settings persistence hard cutover requirements"
    - from: ".planning/ANALYSIS-REFERENCES.md"
      to: "repo_studio_analysis/DECISIONS.md"
      via: "app-runtime-first settings persistence decision"
---

<objective>
Deliver hard cutover for RepoStudio app runtime settings persistence using Payload + SQLite with snapshot/upsert/reset/export APIs.
</objective>

<tasks>
<task type="auto">
  <name>Create settings persistence backbone</name>
  <files>apps/repo-studio/payload.config.ts; apps/repo-studio/payload/collections/repo-settings-overrides.ts; apps/repo-studio/src/lib/settings/*</files>
  <action>Implement collection schema, repository abstraction, merge logic, and deterministic scope resolution (`app < workspace < local`).</action>
  <verify>`pnpm --filter @forge/repo-studio-app build` succeeds with settings repository imported by API routes.</verify>
  <done>Settings snapshot returns `{ app, workspace, local, merged, meta }` with stable shape.</done>
</task>

<task type="auto">
  <name>Wire app runtime APIs and command policy to settings snapshot</name>
  <files>apps/repo-studio/app/api/repo/settings/*; apps/repo-studio/src/lib/command-policy.ts; apps/repo-studio/app/api/repo/commands/*</files>
  <action>Route command view/disabled IDs/confirm policy through settings APIs and merged settings state.</action>
  <verify>Command list/toggle/view APIs round-trip data through settings persistence without local overrides file dependency.</verify>
  <done>RepoStudio app command policy state is persisted through settings API layer.</done>
</task>

<task type="auto">
  <name>Record loop traceability</name>
  <files>.planning/STATE.md; .planning/TASK-REGISTRY.md; .planning/DECISIONS.md; .planning/ERRORS.md</files>
  <action>Capture architectural decisions, migration notes, and any payload/runtime build blockers.</action>
  <verify>`pnpm forge-loop progress --json` remains consistent with active phase/plan state.</verify>
  <done>Planning artifacts reflect the actual cutover status.</done>
</task>
</tasks>
