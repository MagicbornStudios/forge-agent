#!/usr/bin/env node

/**
 * Scans packages/shared/.../showcase/registry/{atoms,molecules,organisms}/*
 * and generates demos/registry.generated.tsx with lazy imports.
 *
 * Entry point per folder: index.tsx or {FolderName}Demo.tsx
 * (e.g. editor-shell-demo -> EditorShellDemo.tsx)
 */

import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, '..');
const registryDir = path.join(
  repoRoot,
  'packages/shared/src/shared/components/docs/showcase/registry'
);
const outputPath = path.join(
  repoRoot,
  'packages/shared/src/shared/components/docs/showcase/demos/registry.generated.tsx'
);

function folderNameToPascal(folderName) {
  return folderName
    .split('-')
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join('');
}

function findEntryPoint(dirPath, folderName) {
  const baseName = folderNameToPascal(folderName);
  const indexPath = path.join(dirPath, 'index.tsx');
  const primaryPath = path.join(dirPath, `${baseName}.tsx`);
  const withDemoName = baseName.endsWith('Demo') ? baseName : baseName + 'Demo';
  const withDemoPath = path.join(dirPath, `${withDemoName}.tsx`);

  if (fs.existsSync(indexPath)) return { file: 'index.tsx', exportName: null };
  if (fs.existsSync(primaryPath)) return { file: `${baseName}.tsx`, exportName: baseName };
  if (fs.existsSync(withDemoPath)) return { file: `${withDemoName}.tsx`, exportName: withDemoName };
  return null;
}

function main() {
  const sections = ['atoms', 'molecules', 'organisms'];
  const entries = [];

  for (const section of sections) {
    const sectionDir = path.join(registryDir, section);
    if (!fs.existsSync(sectionDir)) continue;

    const folders = fs.readdirSync(sectionDir).filter((f) => {
      const p = path.join(sectionDir, f);
      return fs.statSync(p).isDirectory();
    });

    for (const folder of folders.sort()) {
      const dirPath = path.join(sectionDir, folder);
      const entry = findEntryPoint(dirPath, folder);
      if (!entry) {
        const base = folderNameToPascal(folder);
        const withDemo = base.endsWith('Demo') ? base : base + 'Demo';
        process.stderr.write(
          `[build-showcase-registry] skip: ${section}/${folder} - no index.tsx, ${base}.tsx, or ${withDemo}.tsx\n`
        );
        continue;
      }

      const demoId = folder;
      const importPath = `../registry/${section}/${folder}/${path.basename(entry.file, '.tsx')}`;
      const exportName = entry.exportName ?? 'default';
      entries.push({ demoId, importPath, exportName });
    }
  }

  const lazyImports = entries
    .map(
      ({ demoId, importPath, exportName }) =>
        `  '${demoId}': React.lazy(() => import('${importPath}').then((m: any) => ({ default: m.${exportName} ?? m.default })))`
    )
    .join(',\n');

  const content = `/** Generated by scripts/build-showcase-registry.mjs - do not edit */

'use client';

import * as React from 'react';

export const SHOWCASE_REGISTRY: Record<string, React.LazyExoticComponent<React.ComponentType>> = {
${lazyImports}
};
`;

  fs.writeFileSync(outputPath, content, 'utf8');
  process.stdout.write(
    `[build-showcase-registry] wrote ${entries.length} demo(s) to registry.generated.tsx\n`
  );
}

main();
