#!/usr/bin/env node

import process from 'node:process';
import {
  asString,
  getAppConfig,
  getManifestEntries,
  getSelectedApps,
  isEntryRequiredForMode,
  normalizeLineBreaks,
  parseArgs,
  readEnvFile,
  resolveRepoPath,
  writeTextFile,
} from './env/lib.mjs';
import { SECTION_META } from './env/manifest.mjs';

/**
 * @param {'studio'|'platform'} app
 */
function buildDefaults(app) {
  /** @type {Record<string, string>} */
  const defaults = {};
  for (const entry of getManifestEntries(app)) {
    defaults[entry.key] = asString(entry.exampleDefault);
  }
  return defaults;
}

/**
 * @param {'studio'|'platform'} app
 */
function renderExample(app) {
  const entries = getManifestEntries(app);
  const defaults = buildDefaults(app);
  const sectionMeta = SECTION_META[app] ?? {};

  /** @type {string[]} */
  const lines = [
    '# Generated by `pnpm env:sync:examples`.',
    '# Source of truth: scripts/env/manifest.mjs.',
    '# For real values, copy keys into .env.local.',
    '',
  ];

  const sectionOrder = [...new Set(entries.map((entry) => entry.section))];
  for (const section of sectionOrder) {
    const sectionEntries = entries.filter((entry) => entry.section === section);
    const title = sectionMeta[section]?.title ?? section;
    const description = sectionMeta[section]?.description ?? '';

    lines.push(`# -----------------------------------------------------------------------------`);
    lines.push(`# ${title}`);
    if (description.trim().length > 0) {
      lines.push(`# ${description}`);
    }
    lines.push(`# -----------------------------------------------------------------------------`);

    for (const entry of sectionEntries) {
      const requiredModes = entry.requiredIn?.length
        ? ` Required in: ${entry.requiredIn.join(', ')}.`
        : '';
      lines.push(`# ${entry.description}${requiredModes}`);
      const rawValue = defaults[entry.key] ?? '';
      const localRequired = isEntryRequiredForMode(entry, 'local', defaults);
      const line = `${entry.key}=${rawValue}`;
      lines.push(localRequired || entry.localOnly ? line : `# ${line}`);
      lines.push('');
    }
  }

  return `${lines.join('\n').replace(/\n{3,}/g, '\n\n').trimEnd()}\n`;
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const checkMode = options.check === true;
  const apps = getSelectedApps(
    typeof options.app === 'string' ? options.app : undefined,
  );

  let hasChanges = false;
  for (const app of apps) {
    const config = getAppConfig(app);
    const filePath = resolveRepoPath(config.envExamplePath);
    const nextContent = renderExample(app);
    const current = await readEnvFile(filePath);
    const normalizedCurrent = normalizeLineBreaks(current.raw);

    if (normalizedCurrent !== nextContent) {
      hasChanges = true;
      if (checkMode) {
        console.error(
          `[env:sync:examples] ${config.envExamplePath} is out of sync with manifest.`,
        );
      } else {
        await writeTextFile(filePath, nextContent);
        console.log(`[env:sync:examples] wrote ${config.envExamplePath}`);
      }
    } else if (!checkMode) {
      console.log(`[env:sync:examples] no changes for ${config.envExamplePath}`);
    }
  }

  if (checkMode && hasChanges) {
    console.error(
      '[env:sync:examples] Run `pnpm env:sync:examples` and commit regenerated files.',
    );
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('[env:sync:examples] unhandled error:', error);
  process.exit(1);
});

