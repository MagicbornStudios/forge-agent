#!/usr/bin/env node

import process from 'node:process';
import { createInterface } from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import {
  asString,
  buildEnvFile,
  getAppConfig,
  getManifestEntries,
  getSelectedApps,
  isEntryRequiredForMode,
  isValueSet,
  maskValue,
  parseArgs,
  pickUnknownKeys,
  readEnvFile,
  resolveRepoPath,
  writeTextFile,
} from './env/lib.mjs';

/**
 * @param {import('./env/manifest.mjs').ENV_MANIFEST[number]} entry
 * @param {Record<string, string>} values
 * @param {boolean} nonInteractive
 * @param {boolean} fromExample
 * @param {ReturnType<typeof createInterface> | null} rl
 * @param {string} appLabel
 */
async function resolveValue(entry, values, nonInteractive, fromExample, rl, appLabel) {
  const existing = values[entry.key];
  if (isValueSet(existing)) {
    return existing;
  }

  const defaultValue = asString(entry.exampleDefault);
  const required = isEntryRequiredForMode(entry, 'local', values);

  if (nonInteractive) {
    if (fromExample) return defaultValue;
    return required ? defaultValue : '';
  }

  if (!rl) return defaultValue;

  const suffix = required ? 'required' : 'optional';
  const prompt =
    defaultValue.length > 0
      ? `[${appLabel}] ${entry.key} (${suffix}) [${defaultValue}]: `
      : `[${appLabel}] ${entry.key} (${suffix}): `;

  const answer = (await rl.question(prompt)).trim();
  if (answer.length > 0) return answer;
  return defaultValue;
}

/**
 * @param {'studio'|'platform'} app
 * @param {{ nonInteractive: boolean, fromExample: boolean }} options
 */
async function setupApp(app, options) {
  const config = getAppConfig(app);
  const entries = getManifestEntries(app);
  const envPath = resolveRepoPath(config.envLocalPath);
  const existing = await readEnvFile(envPath);
  const values = { ...existing.values };

  /** @type {ReturnType<typeof createInterface> | null} */
  let rl = null;
  if (!options.nonInteractive) {
    rl = createInterface({ input, output });
  }

  try {
    if (!options.nonInteractive) {
      console.log(`\n[env:setup] ${config.label} -> ${config.envLocalPath}`);
      console.log('  Required keys are prompted first, optional missing keys second.');
    }

    for (const entry of entries) {
      if (!isEntryRequiredForMode(entry, 'local', values)) continue;
      const value = await resolveValue(
        entry,
        values,
        options.nonInteractive,
        options.fromExample,
        rl,
        app,
      );
      values[entry.key] = value;
    }

    for (const entry of entries) {
      if (isEntryRequiredForMode(entry, 'local', values)) continue;
      if (isValueSet(values[entry.key])) continue;
      const value = await resolveValue(
        entry,
        values,
        options.nonInteractive,
        options.fromExample,
        rl,
        app,
      );
      if (isValueSet(value) || (options.nonInteractive && options.fromExample)) {
        values[entry.key] = value;
      }
    }
  } finally {
    rl?.close();
  }

  const orderedKeys = entries.map((entry) => entry.key);
  const extras = pickUnknownKeys(existing.values, orderedKeys);
  /** @type {Record<string, string>} */
  const selectedValues = {};
  for (const key of orderedKeys) {
    const value = values[key];
    const entry = entries.find((candidate) => candidate.key === key);
    const required = entry ? isEntryRequiredForMode(entry, 'local', values) : false;
    if (required || isValueSet(value)) {
      selectedValues[key] = value ?? '';
    }
  }

  const fileContent = buildEnvFile(
    [
      '# Generated by `pnpm env:setup`.',
      '# Keep secrets in this file; .env.example is documentation/generated.',
    ],
    selectedValues,
    orderedKeys,
    extras,
  );
  await writeTextFile(envPath, fileContent);

  console.log(`[env:setup] wrote ${config.envLocalPath}`);
  const requiredMissing = entries.filter(
    (entry) =>
      isEntryRequiredForMode(entry, 'local', selectedValues) &&
      !isValueSet(selectedValues[entry.key]),
  );

  console.log('[env:setup] key summary:');
  for (const entry of entries) {
    if (!(entry.key in selectedValues)) continue;
    console.log(
      `  - ${entry.key}: ${maskValue(selectedValues[entry.key], entry.secret === true)}`,
    );
  }
  if (requiredMissing.length > 0) {
    console.warn('[env:setup] missing required local keys:');
    for (const entry of requiredMissing) {
      console.warn(`  - ${entry.key}`);
    }
  }
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const apps = getSelectedApps(typeof options.app === 'string' ? options.app : undefined);
  const nonInteractive = options['non-interactive'] === true;
  const fromExample = options['from-example'] === true;

  for (const app of apps) {
    // eslint-disable-next-line no-await-in-loop
    await setupApp(app, { nonInteractive, fromExample });
  }
}

main().catch((error) => {
  console.error('[env:setup] unhandled error:', error);
  process.exit(1);
});

