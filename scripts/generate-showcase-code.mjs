#!/usr/bin/env node

/**
 * Reads _showcase-code-map.json and pulls source code from mapped files.
 * Writes catalog-code.generated.mjs for use by catalog.ts.
 *
 * Map value: string = single file, array = multiple files.
 * Edit _showcase-code-map.json to add demoId -> sourcePath (or array of paths).
 */

import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, '..');
const showcaseDir = path.join(repoRoot, 'packages/shared/src/shared/components/docs/showcase');
const mapPath = path.join(showcaseDir, '_showcase-code-map.json');
const outputPath = path.join(showcaseDir, 'catalog-code.generated.mjs');

const registryPrefix = 'packages/shared/src/shared/components/docs/showcase/registry/';

const HARNESS_COMMENTS = {
  ShowcaseDemoSurface:
    '// ShowcaseDemoSurface: docs-only styled container for preview. In your app, wrap in your layout (e.g. a simple div or card).\n',
  AssistantDemoHarness:
    '// AssistantDemoHarness: docs-only mock runtime (useLocalRuntime) for preview. In your app, use AssistantRuntimeProvider with your chat backend (e.g. /api/assistant-chat).\n',
};

function transformCode(code) {
  let out = code;
  const comments = [];

  if (out.includes('ShowcaseDemoSurface')) {
    comments.push(HARNESS_COMMENTS.ShowcaseDemoSurface);
  }
  if (out.includes('AssistantDemoHarness')) {
    comments.push(HARNESS_COMMENTS.AssistantDemoHarness);
  }

  // Rewrite imports for consumer-friendly display
  out = out.replace(/from ['"]@forge\/shared['"]/g, "from '@forge/dev-kit'");
  out = out.replace(
    /import \* as UI from ['"]@forge\/ui['"]/g,
    "import { ui } from '@forge/dev-kit'",
  );
  out = out.replace(/\bUI\./g, 'ui.'); // UI.Tabs -> ui.Tabs, etc.
  out = out.replace(
    /from ['"][^'"]*copilot\/generative-ui['"]/g,
    "from '@forge/dev-kit'",
  );

  if (comments.length > 0) {
    out = comments.join('') + '\n' + out;
  }

  return out;
}

function getLanguage(ext) {
  if (ext === '.tsx') return 'tsx';
  if (ext === '.ts') return 'ts';
  if (ext === '.jsx') return 'jsx';
  return 'js';
}

function relativeDisplayPath(sourcePath) {
  if (sourcePath.startsWith(registryPrefix)) {
    return path.basename(sourcePath);
  }
  return path.basename(sourcePath);
}

function main() {
  let map = {};
  if (fs.existsSync(mapPath)) {
    const raw = fs.readFileSync(mapPath, 'utf8');
    map = JSON.parse(raw);
  }

  const output = {};
  for (const [demoId, sourcePathOrPaths] of Object.entries(map)) {
    const paths = Array.isArray(sourcePathOrPaths) ? sourcePathOrPaths : [sourcePathOrPaths];
    const files = [];

    for (const sourcePath of paths) {
      if (typeof sourcePath !== 'string') continue;
      const fullPath = path.join(repoRoot, sourcePath.replace(/\//g, path.sep));
      if (!fs.existsSync(fullPath)) {
        process.stderr.write(`[generate-showcase-code] skip: ${demoId} - file not found: ${sourcePath}\n`);
        continue;
      }
      const rawCode = fs.readFileSync(fullPath, 'utf8');
      const basename = path.basename(sourcePath);
      const ext = path.extname(basename);
      const displayPath = relativeDisplayPath(sourcePath);
      const code = transformCode(rawCode);
      files.push({
        path: displayPath,
        language: getLanguage(ext),
        code,
      });
    }

    if (files.length > 0) {
      output[demoId] = files;
    }
  }

  const content = `/** Generated by scripts/generate-showcase-code.mjs - do not edit */\n\nexport const SHOWCASE_CODE_BY_DEMO_ID = ${JSON.stringify(output, null, 2)};\n`;
  fs.writeFileSync(outputPath, content, 'utf8');
  process.stdout.write(`[generate-showcase-code] wrote ${Object.keys(output).length} demo(s) to catalog-code.generated.mjs\n`);
}

main();
